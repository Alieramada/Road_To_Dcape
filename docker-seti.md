# Docker сети

По умолчанию в контейнерах включена сеть, и они могут устанавливать исходящие соединения. Контейнер не имеет информации о том, к какой сети он подключен и являются ли его одноранговые узлы рабочими нагрузками Docker. Контейнер видит только сетевой интерфейс с IP-адресом, шлюзом, таблицей маршрутизации, службами DNS и другими сетевыми параметрами. Если только контейнер не использует `none` сетевой драйвер.

## Сети определённые пользователем <a href="#user-defined-networks" id="user-defined-networks"></a>

Вы можете создавать собственные пользовательские сети и подключать несколько контейнеров к одной сети. После подключения к пользовательской сети контейнеры могут взаимодействовать друг с другом, используя IP-адреса или имена контейнеров.

```sh
docker network create -d bridge my-net
docker run --network=my-net -itd --name=container3 busybox
```

## Драйвера

| Драйвер   | Описание                                                                      |
| --------- | ----------------------------------------------------------------------------- |
| `bridge`  | Сетевой драйвер по умолчанию.                                                 |
| `host`    | Удалите сетевую изоляцию между контейнером и хостом Docker.                   |
| `none`    | Полностью изолируйте контейнер от хоста и других контейнеров.                 |
| `overlay` | Оверлейные сети соединяют несколько демонов Docker вместе.                    |
| `ipvlan`  | Сети IPvlan обеспечивают полный контроль как над адресацией IPv4, так и IPv6. |
| `macvlan` | Назначьте MAC-адрес контейнеру.                                               |

Подробнее о драйверах [Обзор сетевых драйверов](https://docs.docker.com/engine/network/drivers/).

[Обзор сетевых драйверов](https://docs.docker.com/engine/network/drivers/)

### Контейнерные сети <a href="#container-networks" id="container-networks"></a>

Помимо пользовательских сетей, вы можете напрямую подключить контейнер к сетевому стеку другого контейнера, используя формат `--network container:<name|id>` флага.

Следующие флаги не поддерживаются для контейнеров, использующих `container:` сетевой режим:

* `--add-host`
* `--hostname`
* `--dns`
* `--dns-search`
* `--dns-option`
* `--mac-address`
* `--publish`
* `--publish-all`
* `--expose`

В следующем примере запускается контейнер Redis с привязкой Redis к `localhost`, затем выполняется команда `redis-cli` и подключение к серверу Redis через `localhost` интерфейс.

```sh
$ docker run -d --name redis example/redis --bind 127.0.0.1
$ docker run --rm -it --network container:redis example/redis-cli -h 127.0.0.1
```

## Публикация портов

По умолчанию, когда вы создаете или запускаете контейнер с помощью `docker create` или `docker run` Контейнеры в мостовых сетях не предоставляют доступ к каким-либо портам для внешнего мира. Используйте tон `--publish` или `-p` установите флажок, чтобы сделать порт доступным для служб за пределами мостовой сети. Это создает правило брандмауэра на хосте, сопоставляющее контейнерный порт с портом на хосте Docker для внешнего мира. Вот несколько примеров.:

| Значение флага                  | Описание                                                                                                                                                 |
| ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `-p 8080:80`                    | Сопоставьте порт `8080` на хосте Docker с портом TCP `80` в контейнере.                                                                                  |
| `-p 192.168.1.100:8080:80`      | Сопоставьте порт `8080` на IP-адресе хоста Docker `192.168.1.100` с портом TCP `80` в контейнере.                                                        |
| `-p 8080:80/udp`                | Сопоставьте порт `8080` на хосте Docker с портом UDP `80` в контейнере.                                                                                  |
| `-p 8080:80/tcp -p 8080:80/udp` | Сопоставьте TCP-порт `8080` на хосте Docker с TCP-портом `80` в контейнере и сопоставьте UDP-порт `8080` на хосте Docker с UDP-портом `80` в контейнере. |

{% hint style="info" %}
Публикация портов контейнера по умолчанию небезопасна. Это означает, что при публикации портов контейнера они становятся доступными не только для хоста Docker, но и для внешнего мира.

Если вы укажете IP-адрес локального хоста (`127.0.0.1` или `::1`) с флагом публикации, только хост Docker и его контейнеры смогут получить доступ к опубликованному порту контейнера.

```
docker run -p 127.0.0.1:8080:80 -p '[::1]:8080:80' nginxdocker run -p 127.0.0.1:8080:80 -p '[::1]:8080:80' nginx
```
{% endhint %}

{% hint style="info" %}
Хосты в одном сегменте L2 (например, хосты, подключенные к одному сетевому коммутатору) могут получать доступ к портам, опубликованным на локальном хосте. Дополнительные сведения см. в [moby/moby#45610](https://github.com/moby/moby/issues/45610)
{% endhint %}

## IP - адрес и имя хоста <a href="#ip-address-and-hostname" id="ip-address-and-hostname"></a>

По умолчанию контейнер получает IP-адрес для каждой сети Docker, к которой он подключается. Контейнер получает IP-адрес из IP-подсети сети. Демон Docker выполняет динамическое выделение IP-адресов для контейнеров. Каждая сеть также имеет маску подсети по умолчанию и шлюз.

Вы можете подключить работающий контейнер к нескольким сетям, передав флаг `--network` несколько раз при создании контейнера или используя команду `docker network connect` для уже работающих контейнеров. В обоих случаях вы можете использовать флаги `--ip` или `--ip6` для указания IP-адреса контейнера в конкретной сети.

Аналогичным образом имя хоста контейнера по умолчанию в Docker — это идентификатор контейнера. Вы можете изменить имя хоста с помощью флага  `--hostname`. При подключении к существующей сети с помощью `docker network connect` вы можете использовать флаг `--alias` для указания дополнительного сетевого псевдонима для контейнера в этой сети.

### DNS <a href="#dns-services" id="dns-services"></a>

По умолчанию контейнеры используют те же DNS-серверы, что и хост, но вы можете изменить это с помощью `--dns`.

По умолчанию контейнеры наследуют настройки DNS, определенные в `/etc/resolv.conf` файле конфигурации. Контейнеры, подключенные к `bridge` сети по умолчанию, получают копию этого файла. Контейнеры, подключаемые к пользовательской сети используют встроенный DNS-сервер Docker. Встроенный DNS-сервер перенаправляет запросы внешнего DNS на DNS-серверы, настроенные на хосте.

Вы можете настроить разрешение DNS для каждого контейнера с помощью флагов для команды `docker run` или `docker create` запуска контейнера. В следующей таблице описаны доступные `docker run` флаги, связанные с настройкой DNS.

| Отметить       | Описание                                                                                                                                                                                                                                                                  |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `--dns`        | IP-адрес DNS-сервера. Чтобы указать несколько DNS-серверов, используйте несколько `--dns` флагов. DNS-запросы будут перенаправляться из сетевого пространства имён контейнера, поэтому, например, `--dns=127.0.0.1` относится к собственному петлевому адресу контейнера. |
| `--dns-search` | Домен поиска DNS для поиска не полностью определённых имён хостов. Чтобы указать несколько префиксов поиска DNS, используйте несколько `--dns-search` флагов.                                                                                                             |
| `--dns-opt`    | Пара «ключ-значение», представляющая параметр DNS и его значение. См. документацию вашей операционной системы для `resolv.conf` допустимых параметров.                                                                                                                    |
| `--hostname`   | Имя хоста, которое контейнер использует для себя. По умолчанию используется идентификатор контейнера, если он не указан.                                                                                                                                                  |

## Пользовательские хосты <a href="#custom-hosts" id="custom-hosts"></a>

В вашем контейнере будут строки в `/etc/hosts` , которые определяют имя хоста самого контейнера, а также `localhost` и некоторые другие распространённые параметры. Пользовательские хосты, определённые в `/etc/hosts` на хост-компьютере, не наследуются контейнерами. Чтобы передать дополнительные хосты в контейнер, обратитесь к разделу [добавление записей в файл hosts контейнера](https://docs.docker.com/reference/cli/docker/container/run/#add-host) в справочной документации `docker run` .

### Прокси сервер <a href="#proxy-server" id="proxy-server"></a>

## Настройка прокси-сервера демона

Вы можете настроить поведение прокси-сервера для демона в файле `daemon.json` или с помощью флагов `--http-proxy` или `--https-proxy` для команды `dockerd` в командной строке. Рекомендуется использовать `daemon.json` для настройки.

```json
{
  "proxies": {
    "http-proxy": "http://proxy.example.com:3128",
    "https-proxy": "https://proxy.example.com:3129",
    "no-proxy": "*.test.example.com,.example.org,127.0.0.0/8"
  }
}
```

После изменения файла конфигурации перезапустите демон, чтобы конфигурация прокси-сервера вступила в силу:

```sh
$ sudo systemctl restart docker
```

Демон Docker проверяет следующие переменные среды в своей среде запуска для настройки поведения прокси-сервера HTTP или HTTPS:

* `HTTP_PROXY`
* `http_proxy`
* `HTTPS_PROXY`
* `https_proxy`
* `NO_PROXY`
* `no_proxy`

## Файл модуля systemd <a href="#systemd-unit-file" id="systemd-unit-file"></a>

Если вы запускаете демон Docker как службу systemd, вы можете создать файл systemd, который устанавливает переменные для службы `docker`

> **Примечание для режима без рута**
>
> Расположение файлов конфигурации systemd отличается при запуске Docker в [режиме без прав суперпользователя](https://docs.docker.com/engine/security/rootless/). При запуске в режиме без прав суперпользователя Docker запускается как служба systemd в пользовательском режиме и использует файлы, хранящиеся в домашнем каталоге каждого пользователя в `~/.config/systemd/<user>/docker.service.d/`. Кроме того, `systemctl` должен выполняться без `sudo` и с флагом `--user`. Если вы запускаете Docker в режиме без прав суперпользователя, выберите вкладку «Режим без прав суперпользователя».

1.  Создайте выпадающий каталог systemd для `docker` службы:

    ```sh
    $ sudo mkdir -p /etc/systemd/system/docker.service.d
    ```
2.  Создайте файл с именем `/etc/systemd/system/docker.service.d/http-proxy.conf` который добавляет `HTTP_PROXY` переменную среды:

    ```systemd
    [Service]
    Environment="HTTP_PROXY=http://proxy.example.com:3128"
    ```

    Если вы находитесь за прокси-сервером HTTPS, установите переменную окружения `HTTPS_PROXY`

    ```systemd
    [Service]
    Environment="HTTPS_PROXY=https://proxy.example.com:3129"
    ```

    Можно задать несколько переменных среды; чтобы задать как не-HTTPS, так и HTTP-прокси;

    ```systemd
    [Service]
    Environment="HTTP_PROXY=http://proxy.example.com:3128"
    Environment="HTTPS_PROXY=https://proxy.example.com:3129"
    ```

    > **Примечание**
    >
    > Специальные символы в значении прокси-сервера, такие как `#?!()[]{}`, должны быть экранированы с помощью `%%`. Например:
    >
    > ```systemd
    > [Service]
    > Environment="HTTP_PROXY=http://domain%%5Cuser:complex%%23pass@proxy.example.com:3128/"
    > ```
3.  Если у вас есть внутренние реестры Docker, с которыми вам нужно взаимодействовать без проксирования, вы можете указать их с помощью переменной среды `NO_PROXY`

    Переменная `NO_PROXY` определяет строку, содержащую разделённые запятыми значения для хостов, которые следует исключить из проксирования. Вот параметры, которые можно указать для исключения хостов:

    * Префикс IP-адреса (`1.2.3.4`)
    * Доменное имя или специальная метка DNS (`*`)
    * Доменное имя соответствует этому имени и всем поддоменам. Доменное имя с ведущим «.» соответствует только поддоменам. Например, для доменов `foo.example.com` и `example.com`:
      * `example.com` соответствует `example.com` и `foo.example.com`, и
      * `.example.com` только соответствует `foo.example.com`
    * Одиночная звездочка (`*`) указывает на то, что проксирование выполнять не следует
    * Буквенные номера портов принимаются префиксами IP-адресов (`1.2.3.4:80`) и доменными именами (`foo.example.com:80`)

    Пример:

    ```systemd
    [Service]
    Environment="HTTP_PROXY=http://proxy.example.com:3128"
    Environment="HTTPS_PROXY=https://proxy.example.com:3129"
    Environment="NO_PROXY=localhost,127.0.0.1,docker-registry.example.com,.corp"
    ```
4.  Внесите изменения и перезапустите Docker

    ```bash
    $ sudo systemctl daemon-reload
    $ sudo systemctl restart docker
    ```
5.  Убедитесь, что конфигурация загружена и соответствует внесённым вами изменениям, например:

    ```bash
    $ sudo systemctl show --property=Environment docker

    Environment=HTTP_PROXY=http://proxy.example.com:3128 HTTPS_PROXY=https://proxy.example.com:3129 NO_PROXY=localhost,127.0.0.1,docker-registry.example.com,.corp
    ```

## Настройка клиентской части

Вы можете добавить конфигурации прокси-сервера для клиента Docker с помощью файла конфигурации JSON, расположенного в `~/.docker/config.json`. Сборки и контейнеры используют конфигурацию, указанную в этом файле.

```json
{
 "proxies": {
   "default": {
     "httpProxy": "http://proxy.example.com:3128",
     "httpsProxy": "https://proxy.example.com:3129",
     "noProxy": "*.test.example.com,.example.org,127.0.0.0/8"
   }
 }
}
```

> **Предупреждение**
>
> Настройки прокси-сервера могут содержать конфиденциальную информацию. Например, некоторые прокси-серверы требуют, чтобы в их URL-адрес была включена информация для аутентификации, или их адрес может раскрывать IP-адреса или имена хостов вашей компании.
>
> Переменные среды хранятся в виде обычного текста в конфигурации контейнера и могут быть проверены с помощью удалённого API или зафиксированы в образе при использовании `docker commit`.

Конфигурация становится активной после сохранения файла, перезапускать Docker не нужно. Однако конфигурация применяется только к новым контейнерам и сборкам и не влияет на существующие контейнеры.

В следующей таблице описаны доступные параметры конфигурации.

| Свойство     | Описание                                                                         |
| ------------ | -------------------------------------------------------------------------------- |
| `httpProxy`  | Устанавливает `HTTP_PROXY` и `http_proxy` переменные среды и аргументы сборки.   |
| `httpsProxy` | Устанавливает `HTTPS_PROXY` и `https_proxy` переменные среды и аргументы сборки. |
| `ftpProxy`   | Устанавливает `FTP_PROXY` и `ftp_proxy` переменные среды и аргументы сборки.     |
| `noProxy`    | Устанавливает `NO_PROXY` и `no_proxy` переменные среды и аргументы сборки.       |
| `allProxy`   | Устанавливает `ALL_PROXY` и `all_proxy` переменные среды и аргументы сборки.     |

Эти настройки используются для конфигурации переменных среды прокси-сервера только для контейнеров и не используются в качестве настроек прокси-сервера для Docker CLI или самого Docker Engine. Для настройки прокси-сервера для Docker CLI и Docker Engine см. разделы [«Переменные среды»](https://docs.docker.com/reference/cli/docker/#environment-variables) и [«Настройка демона Docker для использования прокси-сервера»](https://docs.docker.com/engine/daemon/proxy/).

## Запуск контйнеров с настройкой прокси <a href="#run-containers-with-a-proxy-configuration" id="run-containers-with-a-proxy-configuration"></a>

При запуске контейнера его переменные среды, связанные с прокси-сервером, настраиваются в соответствии с конфигурацией прокси-сервера в `~/.docker/config.json`.

Например, при использовании конфигурации прокси-сервера, подобной той, что показана в предыдущем разделе, переменные среды для запускаемых вами контейнеров устанавливаются следующим образом:

```sh
$ docker run --rm alpine sh -c 'env | grep -i  _PROXY'
https_proxy=http://proxy.example.com:3129
HTTPS_PROXY=http://proxy.example.com:3129
http_proxy=http://proxy.example.com:3128
HTTP_PROXY=http://proxy.example.com:3128
no_proxy=*.test.example.com,.example.org,127.0.0.0/8
NO_PROXY=*.test.example.com,.example.org,127.0.0.0/8
```

#### Сборка с использованием конфигурации прокси-сервера <a href="#build-with-a-proxy-configuration" id="build-with-a-proxy-configuration"></a>

При запуске сборки аргументы сборки, связанные с прокси-серверами, автоматически заполняются на основе настроек прокси-сервера в файле конфигурации клиента Docker.

При условии, что конфигурация прокси-сервера аналогична примеру, показанному в предыдущем разделе  во время сборки устанавливаются следующие переменные среды:

```console
$ docker build \
  --no-cache \
  --progress=plain \
  - <<EOF
FROM alpine
RUN env | grep -i _PROXY
EOF
```

```console
#5 [2/2] RUN env | grep -i _PROXY
#5 0.100 HTTPS_PROXY=https://proxy.example.com:3129
#5 0.100 no_proxy=*.test.example.com,.example.org,127.0.0.0/8
#5 0.100 NO_PROXY=*.test.example.com,.example.org,127.0.0.0/8
#5 0.100 https_proxy=https://proxy.example.com:3129
#5 0.100 http_proxy=http://proxy.example.com:3128
#5 0.100 HTTP_PROXY=http://proxy.example.com:3128
#5 DONE 0.1s
```

## Настройка прокси сервера для каждого демона <a href="#configure-proxy-settings-per-daemon" id="configure-proxy-settings-per-daemon"></a>

Ключ `default` в `proxies` в `~/.docker/config.json` настраивает параметры прокси для всех демонов, к которым подключается клиент. Чтобы настроить прокси для отдельных демонов, используйте адрес демона вместо ключа `default`.

В следующем примере настраивается как конфигурация прокси-сервера по умолчанию, так и переопределение прокси-сервера для демона Docker по адресу `tcp://docker-daemon1.example.com`:

```json
{
 "proxies": {
   "default": {
     "httpProxy": "http://proxy.example.com:3128",
     "httpsProxy": "https://proxy.example.com:3129",
     "noProxy": "*.test.example.com,.example.org,127.0.0.0/8"
   },
   "tcp://docker-daemon1.example.com": {
     "noProxy": "*.internal.example.net"
   }
 }
}
```

### Настройка прокси с помощью командной строки <a href="#set-proxy-using-the-cli" id="set-proxy-using-the-cli"></a>

Вместо настройки клиента вы можете указать конфигурации прокси в командной строке при вызове команд `docker build` и `docker run`.

Для настройки прокси-сервера в командной строке используется флаг `--build-arg` для сборок и флаг `--env` для запуска контейнеров с прокси-сервером.

```sh
$ docker build --build-arg HTTP_PROXY="http://proxy.example.com:3128" .
$ docker run --env HTTP_PROXY="http://proxy.example.com:3128" redis
```

Список всех аргументов сборки, связанных с прокси-серверами, которые можно использовать с командой `docker build`, см. в разделе [Предопределённые аргументы сборки](https://docs.docker.com/reference/dockerfile/#predefined-args). Эти значения прокси-серверов доступны только в контейнере сборки. Они не включаются в результат сборки.

### [Прокси как переменная среды для сборок](https://docs.docker.com/engine/cli/proxy/#proxy-as-environment-variable-for-builds) <a href="#proxy-as-environment-variable-for-builds" id="proxy-as-environment-variable-for-builds"></a>

Не используйте инструкцию `ENV` Dockerfile для указания настроек прокси-сервера при сборке. Вместо этого используйте аргументы сборки.

При использовании переменных среды для прокси-серверов конфигурация встраивается в образ. Если прокси-сервер является внутренним, он может быть недоступен для контейнеров, созданных на основе этого образа.

Включение настроек прокси в изображения также представляет угрозу безопасности, поскольку значения могут содержать конфиденциальную информацию.\
